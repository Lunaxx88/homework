#include <iostream>#include <memory>#include <math.h>#include<iterator>using namespace std;class node {public:	int value;	shared_ptr<node> right;	shared_ptr<node> l_child;	shared_ptr<node> r_child;	node() {}	node(int i) { value = i; }};class tree {public:	shared_ptr<node> root;	int level;	tree() { level = 0; }	//void connectTwoTrees(shared_ptr<node> root1, shared_ptr<node> root2) {	//	while (root1 != nullptr) {	//		root1->right = root2;	//		root1 = root1->r_child;	//		root2 = root2->l_child;	//	}	//}	//Implement all member functions below	tree(int n);//constructor for n-level tree	//and initilize values as shown in the diagram; 0, 1, 2, ...	//Note that root node is at level 1 and its value will be initialized to 0	tree(const tree &T);//copy constructor	~tree();//destructor	tree(tree &&T); //move constructor	tree(const initializer_list<int> &V);//The first number in V is tree level;	//the rest are values from top to bottom and from left to right	//For example, to create the tree with n=3 in the diagram,	//tree T1 = {3, 0,1,2,3,4,5,6}; //where the first 3 is tree level, and the rest are values	void operator= (const tree &R);//L-value operator=	void operator= (tree &&R); //R-value operator=	tree ThreeTimes(); //return a tree with all node value being three times		friend ostream& operator<<(ostream& str, const tree& T);	int sum(shared_ptr<node> p);//sum of node values in sub-tree rooted at p	void delete_level(int i); // Delete nodes at level i. Some nodes at level(s) higher	//than i will also be deleted accordingly. As described in class.  (Also see the	//example in the main function.)	shared_ptr<node> find(int i);//find the first node with value i and return	//its address; if not found, return nullptr;}; ostream& operator<<(ostream& str, const tree& T) {	for (shared_ptr<node> ptr = T.root; ; ptr = ptr->right) {		str << ptr->value << ' ';		if (ptr->right == T.root) {			break;		}	}	str << '\n';	return str;}shared_ptr<node>tree::find(int i) {	shared_ptr<node> sp = make_shared<node>();	for (sp = root; ; sp = sp->right) {		if (sp->value == i)		{			return sp;		}		if (sp->right == root) {			break;		}	}	return nullptr;}tree::tree(int n) {//constructor for n-level tree	level = n;	if (n <= 0) {		// TODO  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!		return;	}	int curLevel = 1;	int curFirst = 1; // 2^(n - 1)	root = make_shared<node>(0);	shared_ptr<node> previousPtr = root;	shared_ptr<node> curNode = root;	for (; curLevel <= n - 1; curLevel++) {		for (int i = 0; i < curFirst; i++) {			// 1. create child nodes			curNode->l_child = make_shared<node>(2 * (curFirst - 1 + i) + 1);			curNode->r_child = make_shared<node>(2 * (curFirst - 1 + i) + 2);			previousPtr->right = curNode->l_child;			curNode->l_child->right = curNode->r_child;			previousPtr = curNode->r_child;			curNode = curNode->right;		}		curFirst *= 2;	}	previousPtr->right = root;}tree::tree(const tree& T) {	level = T.level;		shared_ptr<node> nd;	nd = T.root;	//this->level = level;		if (level <= 0) {		// TODO  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!		return;	}	int curLevel = 1;	int curFirst = 1; // 2^(n - 1)	root = make_shared<node>(nd->value);	nd = nd->right;	shared_ptr<node> previousPtr = root;	shared_ptr<node> curNode = root;	for (; curLevel <= level - 1; curLevel++) {		for (int i = 0; i < curFirst; i++) {			// 1. create child nodes			curNode->l_child = make_shared<node>(nd->value);			nd = nd->right;			curNode->r_child = make_shared<node>(nd->value);			nd = nd->right;			previousPtr->right = curNode->l_child;			curNode->l_child->right = curNode->r_child;			previousPtr = curNode->r_child;			curNode = curNode->right;		}		curFirst *= 2;	}	previousPtr->right = root;}//copy constructortree::~tree() {	if (!root)		return;	root->right.reset();	root->l_child.reset();	root->r_child.reset();	root.reset();		cout << "Leaving destructor" << endl;}//destructortree::tree(tree&& T) {	level = T.level;	root = T.root;	T.level = 0;	T.root.reset();	//T.root = nullptr;	cout << "leaving move constructor" << endl;} //move constructortree::tree(const initializer_list<int>& V) {	//The first number in V is tree level;	//the rest are values from top to bottom and from left to right	//For example, to create the tree with n=3 in the diagram,	//tree T1 = {3, 0,1,2,3,4,5,6}; //where the first 3 is tree level, and the rest are values	auto it = V.begin();	this->level = *it;	it++;	if (*it <= 0) {		// TODO  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!		return;	}	int curLevel = 1;	int curFirst = 1; // 2^(n - 1)	root = make_shared<node>(*it);	it++;	shared_ptr<node> previousPtr = root;	shared_ptr<node> curNode = root;		for (; curLevel <= level - 1; curLevel++) {		for (int i = 0; i < curFirst; i++) {			// 1. create child nodes			curNode->l_child = make_shared<node> (* it);			it++;			curNode->r_child = make_shared<node> (* it);			it++;			previousPtr->right = curNode->l_child;			curNode->l_child->right = curNode->r_child;			previousPtr = curNode->r_child;			curNode = curNode->right;					}		curFirst *= 2;	}	previousPtr->right = root;}void tree:: operator= (const tree& R) {	level = R.level;	shared_ptr<node> nd;	nd = R.root;	//this->level = level;	if (level <= 0) {		// TODO  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!		return;	}	int curLevel = 1;	int curFirst = 1; // 2^(n - 1)	root = make_shared<node>(nd->value);	nd = nd->right;	shared_ptr<node> previousPtr = root;	shared_ptr<node> curNode = root;	for (; curLevel <= level - 1; curLevel++) {		for (int i = 0; i < curFirst; i++) {			// 1. create child nodes			curNode->l_child = make_shared<node>(nd->value);			nd = nd->right;			curNode->r_child = make_shared<node>(nd->value);			nd = nd->right;			previousPtr->right = curNode->l_child;			curNode->l_child->right = curNode->r_child;			previousPtr = curNode->r_child;			curNode = curNode->right;		}		curFirst *= 2;	}	previousPtr->right = root;	cout << "Leaving L-value operator=" << endl;}//L-value operator=void tree::operator= (tree&& R) {		if (!root)		return;	root->right.reset();	root->l_child.reset();	root->r_child.reset();	root.reset();	root = R.root;	level = R.level;	(R.root).reset();	R.level = 0;		//R.root = nullptr;???????	cout << "Leaving R-value operator=" << endl;}tree tree::ThreeTimes() {	tree tmp;	shared_ptr<node> nd;	 tmp.root = root;	 tmp.level = level;	 nd = tmp.root;	if (tmp.level <= 0) {		// TODO  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!		return 0;	}	int curLevel = 1;	int curFirst = 1; // 2^(n - 1)	int k = nd->value * 3;	tmp.root = make_shared<node>(k);	nd = nd->right;	shared_ptr<node> previousPtr = tmp.root;	shared_ptr<node> curNode = tmp.root;	for (; curLevel <= tmp.level - 1; curLevel++) {		for (int i = 0; i < curFirst; i++) {			// 1. create child nodes			curNode->l_child = make_shared<node>(nd->value*3);			nd = nd->right;			curNode->r_child = make_shared<node>(nd->value*3);			nd = nd->right;			previousPtr->right = curNode->l_child;			curNode->l_child->right = curNode->r_child;			previousPtr = curNode->r_child;			curNode = curNode->right;		}		curFirst *= 2;	}	previousPtr->right = tmp.root;	this;	return tmp;// tmp is nullptr}int tree::sum(shared_ptr<node> p) {	if (p == nullptr) return 0;	shared_ptr<node> p1 = p;	shared_ptr<node> p2 = p;	int psum = p->value;	if (p->r_child && p->l_child) {		psum = psum + sum(p->r_child) + sum(p->l_child);	}	return psum;}void tree::delete_level(int i) {	if (i <= 0) {		return;	}		int level = i;	//int curLevel = 1;	int curFirst = 1; // 2^(n - 1)	//root = make_shared<node>(0);	shared_ptr<node> previousPtr = root;	shared_ptr<node> curNode = root;	shared_ptr<node> nexNode = root;	shared_ptr<node> firstparent = root;	//int curlevel = pow(2, level);	for (int i = 1; i <= pow(2, level - 2)-1 ; i++) {		firstparent = firstparent->right;	}	//first node in above level	//second node is the last node in above level	shared_ptr<node> lastparent = firstparent;	shared_ptr<node> FP = firstparent;	for (int i = 1; i < pow(2, level - 2) ; i++) {		lastparent = lastparent->right;	}	/////curNode = lastparent->right;	////1st: parent->right ==.....	//cout << lastparent->value << firstparent->value;	if (firstparent->l_child) {		if (firstparent->l_child->l_child) {			lastparent->right = firstparent->l_child->l_child;		}		else {			for (int i = 0; i < pow(2, level - 2) - 1; i++) {				firstparent->l_child.reset();				firstparent->r_child.reset();				firstparent = firstparent->right;			}			firstparent->l_child.reset();			firstparent->r_child.reset();			firstparent->right = root;			return;		}	}	else return;			//2nd: node->	//if (firstparent->l_child->l_child) {		for (int i = 0; i < pow(2, level - 2); i++) {			firstparent->l_child = firstparent->l_child->l_child;			firstparent->r_child = firstparent->r_child->l_child;			firstparent = firstparent->right;			}	//}	//firstnode is in the lower level	/*int count = 1;	int n  = 0;	int m = 0;*/	//int time = pow(2, level - 1)-1;	//firstparent = firstparent->right;	//curNode = firstparent;	//nexNode = firstparent;				shared_ptr<node> L;		shared_ptr<node> R;		shared_ptr<node> Q;	for (shared_ptr<node> pN = FP; pN != lastparent->right; pN = pN->right) {		// l_child connect to r_child		L = pN->l_child;		R = pN->r_child;		while (L != nullptr) {			L->right = R;			L = L->r_child;			R = R->l_child;		}		//connectTwoTrees(pN->l_child, pN->r_child);		// r_child connect to next l_child		if (pN == lastparent) {			break;		}		R = pN->r_child;		 Q = pN->right->l_child;		while (R != nullptr) {			R->right = Q;			R = R->r_child;			Q = Q->l_child;		}	}	//void connectTwoTrees(shared_ptr<node> root1, shared_ptr<node> root2) {	//	while (root1 != nullptr) {	//		root1->right = root2;	//		root1 = root1->r_child;	//		root2 = root2->l_child;	//	}	//}	shared_ptr<node> end = lastparent;	shared_ptr<node> start = FP->l_child;	while (start != nullptr) {		end->right = start;		start = start->l_child;		end = end->r_child;	}	shared_ptr<node> p = lastparent;	while (p->r_child != nullptr) {		p = p->r_child;	}	p->right = root;	//while (curNode->right != root) {	//	for (int t = 0; t <= pow(2, level - 1) - 1; t++) {	//		for (int i = 0; i <= count; i++) {	//			nexNode = nexNode->right;	//		}	//		curNode->right = nexNode;	//		curNode = nexNode;	//		for (int i = 1; i < m; i++) {	//			curNode = curNode->right;	//		}	//		nexNode = curNode;	//	}	//	count++;	//	n++;	//	m = pow(2, n - 1);	//}				//3rd: parent->lchild = parent->lchild->lchild	//curNode->right = root;} // Delete nodes at level i. Some nodes at level(s) higher//than i will also be deleted accordingly. As described in class.  (Also see the//example in the main function.)int main() {	tree T1(3);	cout << T1 << endl; //will print 0 1 2 3 4 5 6	tree T2 = { 4, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, };	cout << T2 << endl; //will print 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24	tree T3(T2);	cout << T3 << endl; //will print 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24	tree T4;	T4 = T3;	cout << T4 << endl; //will print 10 11 2 13 14 15 16 17 18 19 20 21 22 23 24	T4 = T3.ThreeTimes();	cout << T4 << endl;//will print 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72	T4.delete_level(3);	cout << T4 << endl;//will print 30 33 36 51 57 63 69	cout << T3.sum(T3.find(12)) << endl; //will print 133	getchar();	getchar();	return 0;}